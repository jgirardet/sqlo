// CREATE TABLE maison (
//   id INTEGER NOT NULL PRIMARY KEY,
//   adresse TEXT NOT NULL,
//   taille INTEGER NOT NULL,
//   piscine BOOLEAN
// );

// CREATE TABLE piece (
//   id UUID NOT NULL PRIMARY KEY,
//   lg INTEGER NOT NULL,
//   la INTEGER NOT NULL,
//   maison_id INTEGER NOT NULL,
//   FOREIGN KEY(maison_id) REFERENCES maison(id)
// );

use uuid::Uuid;

macro_rules! uu4 {
    (1) => {
        uuid::uuid!("11111111111111111111111111111111")
    };
}

// without any attr
#[derive(sqlo::Sqlo, Debug, PartialEq)]
struct Maison {
    // #[sqlo(type_override)]
    id: i64,
    adresse: String,
    taille: i64,
    piscine: Option<bool>,
}

// with a single attr in sqlo attr
#[derive(sqlo::Sqlo, PartialEq, Debug)]
#[sqlo(tablename = "piece")]
struct WithAttrs {
    #[sqlo(primary_key, type_override, create_fn = "uuid::Uuid::new_v4")]
    nb: Uuid,
    #[sqlo(type_override, column = "lg")]
    lglg: i32,
    la: i64,
    maison_id: i64,
}

#[derive(sqlo::Sqlo, PartialEq, Debug)]
#[sqlo(tablename = "maison")]
struct Maison2 {
    #[sqlo(create_arg, type_override)]
    id: i32,
    adresse: String,
    taille: i64,
    piscine: Option<bool>,
}
// impl Maison2 {
//     fn random_id() -> i32 {
//         2353454
//     }
// }

#[async_std::main]
async fn main() {
    let pool = sqlx::SqlitePool::connect(&std::env::var("DATABASE_URL").unwrap())
        .await
        .unwrap();

    //  ------------------- Test additional utils ------------------------------//

    //test tablname
    assert_eq!(
        Maison::tablename(),
        "maison",
        "tablename is derived from struct name"
    );
    assert_eq!(
        WithAttrs::tablename(),
        "piece",
        "attribute tablename force override tablename"
    );

    //test utils as instance
    let m = Maison::get(&pool, 1).await.unwrap();
    assert_eq!(m.itablename(), "maison");

    //  ------------------- Test get and Attribute ------------------------------//

    //test get
    let m = Maison::get(&pool, 1).await.unwrap();
    assert_eq!(m.adresse, "adresse1", "test get method");

    // test primary_key attirbute
    let p = WithAttrs::get(&pool, uu4!(1)).await.unwrap(); //

    // test type_override
    let m2 = Maison2::get(&pool, 1).await.unwrap(); //typeoverride
    assert_eq!(m2.id, 1i32, "type_override converte i32 instead of i64");

    // test column rename
    assert_eq!(
        p,
        WithAttrs {
            nb: uu4!(1),
            lglg: 1,
            la: 10,
            maison_id: 1
        }
    );

    //  ------------------- Test create  ------------------------------//

    // test create : primary_key auto generated by db
    // test create returning option and non option
    let nm = Maison::create(&pool, "labas".to_string(), 23, None)
        .await
        .unwrap();
    assert_eq!(nm.adresse, "labas".to_string());
    let nmm = Maison::get(&pool, nm.id).await.unwrap();
    assert_eq!(nm, nmm);

    // test create with `create` attribute
    let nm2 = Maison2::create(&pool, 999, "le999".to_string(), 9, None)
        .await
        .unwrap();
    assert_eq!(nm2.id, 999i32);

    // test create with `create_fn` attribute
    let wa = WithAttrs::create(&pool, 123, 12, 1).await.unwrap();
    wa.nb.as_hyphenated(); //test uuid type by ducj typing

    //  ------------------- Test save ------------------------------//

    //test save from new instance not in database
    let mut sn = Maison {
        id: 123,
        adresse: "zef".to_string(),
        taille: 234,
        piscine: Some(true),
    };
    sn.save(&pool).await.unwrap();
    let snn = Maison::get(&pool, 123).await.unwrap();
    assert_eq!(sn, snn);

    //test save  with instance already saved
    sn.adresse = "AA".to_string();
    sn.save(&pool).await.unwrap();
    assert_eq!(
        Maison::get(&pool, 123).await.unwrap().adresse,
        "AA".to_string()
    );

    //  ------------------- Test sqlo_set // update ------------------------------//

    // test update one field with same name / column
    let sn = set_Maison![&pool, sn, adresse = "BB"].await.unwrap();
    assert_eq!(
        Maison::get(&pool, 123).await.unwrap().adresse,
        "BB".to_string()
    );

    // test update more than one field with same name / column
    set_Maison![&pool, sn, adresse = "CC", taille = 999]
        .await
        .unwrap();
    assert_eq!(
        Maison::get(&pool, 123).await.unwrap().adresse,
        "CC".to_string()
    );
    assert_eq!(Maison::get(&pool, 123).await.unwrap().taille, 999);

    // test updaet with different column/field name
    let p = WithAttrs::get(&pool, uu4!(1)).await.unwrap(); //
    let q = set_WithAttrs![&pool, p, lglg = 123789].await.unwrap();
    let r = WithAttrs::get(&pool, uu4!(1)).await.unwrap(); //
    assert_eq!(q.lglg, 123789);
    assert_eq!(q, r);

    // test update with update like instance syntax
    let r = set_WithAttrs![&pool, r, lglg = 23].await.unwrap();
    assert_eq!(r.lglg, 23);

    // ----------------- End -----------------------------------//
    println!("Sqlite Maison succeds !!!")
}
